                                                 Redis


Redis stands for REmote DIctionary Server.

Remote : Distributed
Dictionary : Hastable/Map/HashMap

Data structure which stores data and which is distributed.

Redis is written in c language. Redis is written on unix platforms- linux,osx.


Redis distribution

Mode of Distribution:

1.Open source - Redis.io
2.Commerical  - Redis cloud - redislabs

Redis Platform:
..............
Redis is officially available on unix,linux,bsd versions only.
redis is not available on windows.

Redis is available on windows 
-via docker.
-via third party - it is not stable.

Ridis use cases:
...............

1.caching.
2.Session management
3.Message broker
4.Gaming
5.as database.


Redis installation:
..................
->source code : build from source
->binary
//////////////////////////////////////////////////////////////////////////////////////////

How to install redis?

-open source - on linux

 - build from source.

-open source - on windows
  -docker - for development only.

Steps:
1.sudo apt-get update
2.wget https://download.redis.io/releases/redis-6.2.1.tar.gz
3.tar xzf redis-6.2.1.tar.gz
4.install compilers
5.build using make.

redis distribution dir structure:

1.redis-6.0.9/src
 -all source code - .c and .h files

2.redis-6.0.9/deps
 contains all compiler related things- cc, gcc.
 in order compile the files we need compilers
 memory allocators
3.redis-6.0.9/tests
   To test stability of redis components.

4.redis-6.0.9/utils
   contains ulities for administration,dev,testing redis.

Files:

bug reports:https://github.com/redis/redis/issues

redis configuration file:
redis.conf
  Redis server uses this file for starting and applying all redis admin features  
 

Lab 1: How to run redis server?

redis server can be started in two mode in general

1.log mode

$ src/redis-server

27874:C 15 Mar 2021 11:20:14.207 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
27874:C 15 Mar 2021 11:20:14.207 # Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=27874, just started
27874:C 15 Mar 2021 11:20:14.207 # Warning: no config file specified, using the default config. In order to specify a config file use src/redis-server /path/to/redis.conf
27874:M 15 Mar 2021 11:20:14.208 * Increased maximum number of open files to 10032 (it was originally set to 1024).
27874:M 15 Mar 2021 11:20:14.208 * monotonic clock: POSIX clock_gettime
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 6.2.1 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 27874
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

27874:M 15 Mar 2021 11:20:14.208 # Server initialized
27874:M 15 Mar 2021 11:20:14.208 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
27874:M 15 Mar 2021 11:20:14.209 * Loading RDB produced by version 6.2.1
27874:M 15 Mar 2021 11:20:14.209 * RDB age 50 seconds
27874:M 15 Mar 2021 11:20:14.209 * RDB memory usage when created 0.83 Mb
27874:M 15 Mar 2021 11:20:14.209 * DB loaded from disk: 0.000 seconds
27874:M 15 Mar 2021 11:20:14.209 * Ready to accept connections


2.detached mode - back ground process.

Since redis is a c program, which has main method.

int main(char* args){
  chars *myargs=args;
}
args are used to pass command line args- options; value we pass to process during runtime.

syntax :

src/redis-server  --options

eg:
$src/redis-server --daemonize yes



Lab 2 : how to connect redis server?

 you need to communicate redis server, we need redis clients.

Redis can be connected with most of the programming languages
     -java, javascript,python,c#,Ruby,C,C++..........

Every programming lang has dirivers to connect redis server.

Redis offers built in cli tool - redis-cli
 command line tool to talk to redis server.
this tool mostly used by administors

Lab 3: How to connect redis via redis cli?

Hand shaking processing:

$src/redis-cli
127.0.0.1:6379> PING
PONG
127.0.0.1:6379> PING "Hello Redis!"
"Hello Redis!"
127.0.0.1:6379>

Lab 4 : How to stop running redis server?

>127.0.0.1:6379> shutdown
not connected>

after shutting down, if you try to connect server you will get the following error.

Could not connect to Redis at 127.0.0.1:6379: Connection refused.

Lab 5: How to change default port?

--port parameter

$src/redis-server --port 6380

How to connect via cli if port is different

 src/redis-cli
Could not connect to Redis at 127.0.0.1:6379: Connection refused

by default redis-cli has been configured to connect with 6379 port only. if port change
we need to tell explicit port.

Like redis server redis-cli takes parameter, parameter should be passed with "-" 
 -p

$src/redis-cli -p 6380

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Lab 6: How to start multiple redis instances?

redis can be started n-no of instances.

Redis server can be classified into 2 category based on server startup?

1.standalone mode

2.Replica mode
  2.1.cluster mode

Multiple redis instances in standalone mode?
 just run servers in different ports.
 
src/redis-server --daemonize yes
src/redis-server --daemonize yes --port 6380
src/redis-server --daemonize yes --port 6381

src/redis-cli 

src/redis-cli -p 6380
src/redis-cli -p 6381
//////////////////////&&&&&&&&&&&&&&&&&/////////////////////////////////////////////////////

Task : How to inspect redis.conf file.

1.Redis is able to start without a configuration file using a "built-in default configuration".
2.However this setup is only recommended for testing and development purposes.
3.redis conf file has values defined by "directives".
  directive is just variable having value.
 
   keyword arg1 arg2 argN
   (directive)

   daemonize no

3.# - symbol is used to disable configuration or to represent documentation

   # Genernal 

///////////////////////////////////////////////////////////////////////////////////////////

Redis General Concepts:


1.Redis is key-value pair data store.

 Data storage in redis is based keys.
 A key can be maped with single or compsit values.

2.Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams.

3.commands ;
  like sql commands(select,insert,update,grant,commit) , redis offers commands.
  commands are apis supplied to redis-server will run command and will give response.

 generally commands are classified into 2.

  - request related (write) - Set
  - response related (read) - get


Lab 7: How to save simple data into redis server?
Command:

SET 
GET

SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]

127.0.0.1:6379> SET message "Hello Redis!!"
OK

Here We send key via set command to server, server will execute that command, stores data with
key-value, once success it returns RESPONSE - OK.

GET key

127.0.0.1:6379> GET message
"Hello Redis!!"
/////////////////////////////////////////////////////////////////////////////////////////////
Commands: Keys:
..............

How to read all keys or some of the keys?

 KEYS
 SCAN

Returns all keys matching pattern.

127.0.0.1:6379> KEYS *
1) "message"

127.0.0.1:6379> KEYS m?ssage
1) "message"

Redis uses glob-style pattern similar to regex pattern.
https://en.wikipedia.org/wiki/Glob_(programming) - *,?,?? []


Keys
-Blocks until complete
   lets say database contains million keys, it blocks database long time
 Recommendation : dont use in production, use it in dev and testing env only.

Redis Process Architecture:
...........................

1.Redis is single threaded.
  
Non blocking and async arch.
   Redis since single threaded all heavy or long running process are handed over to kernal 
space like epoll or Kqueue.

Redis server is async non blocking server.
 Redis can schedule long running tasks in the background, without affecting the running
 redis server



Scan :
  iterates over cursor
  it also blocks but only iterates over handful  of keys at  the time.
  Returns slot references
  May return 0 or more keys per call.
  Safe for production.


127.0.0.1:6379> scan 0 MATCH *
1) "15"
2)  1) "a"
    2) "c1"
    3) "c"
    4) "d"
    5) "d1"
    6) "b"
    7) "message"
    8) "e"
    9) "a1"
   10) "e1"
127.0.0.1:6379> scan 15 MATCH *
1) "15"
2)  1) "a"
    2) "c1"
    3) "c"
    4) "d"
    5) "d1"
    6) "b"
    7) "message"
    8) "e"
    9) "a1"
   10) "e1"
127.0.0.1:6379> scan 0 MATCH * COUNT 4
1) "14"
2) 1) "a"
   2) "c1"
   3) "c"
   4) "d"
127.0.0.1:6379> scan 14 MATCH * COUNT 4
1) "9"
2) 1) "d1"
   2) "b"
   3) "message"
   4) "e"
127.0.0.1:6379> scan 9 MATCH * COUNT 4
1) "0"
2) 1) "a1"
   2) "e1"
   3) "b1"
127.0.0.1:6379> scan 0 MATCH * COUNT 4
1) "14"
2) 1) "a"
   2) "c1"
   3) "c"
   4) "d"
127.0.0.1:6379>

//////////////////////////////////////////////////////////////////////////////////////////////
Redis Key Modeling Patterns: Redis community Recommendation:
............................................................

KEY NAME:

Plain keynames
   A    10
   X    20
   name "subramanian"

Redis coding standard:
  objectname:identifier:subidentifier

i want to store order status

  order:1  available
  order:2  outofstock
  order:3  pending
  user:1:status online

127.0.0.1:6379> SET order:1 "available"
OK
127.0.0.1:6379> SET order:1 "available"
OK
127.0.0.1:6379> get order:2 "outofstock"
OK
127.0.0.1:6379> set user:1:status online
OK
127.0.0.1:6379> set user:2:status online
OK
127.0.0.1:6379> set user:3:status offline


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

KEYS REMOVAL: DEL and Unlink
/////////////////////////////


KEYS REMOVAL: DEL and Unlink
/////////////////////////////


DEL key [key ...]

Removes the specified keys. A key is ignored if it does not exist.

Return value
Integer reply: The number of keys that were removed.

-The DEL Command will remove the key and memory associated with the key.
-This is performed as a blocking opertion.

UnLink:
......
-With UNLINK, key is unlinked , hence the name of the  command and will no longer exists.
-The memory associated with the key value is reclaimed by an asynchronous process,so the UNLINK is a  non-blocking command.


127.0.0.1:6379> DEL a
(integer) 1
127.0.0.1:6379> DEL a a1
(integer) 1
127.0.0.1:6379> DEL b b1
(integer) 2
127.0.0.1:6379> UNLINK  c c1
(integer) 2
127.0.0.1:6379> get c
(nil)
127.0.0.1:6379> get a
(nil)
127.0.0.1:6379>

Note:
 if key does not exit , it returns "nil"



///////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////

However, there are times when you only want to set the value if the key already exists.

EXISTS key [key ...]

EXISTS customer:1000
127.0.0.1:6379> EXISTS customer:2000
(integer) 1
127.0.0.1:6379> EXISTS customer:9000
(integer) 0
127.0.0.1:6379>

it returns 1 for key present , 0 means no key present



Use case :

Why should i use exits command to verify the existing of key.

Operations:
 - new Key - insert
 - update key  -  update.

-SET Command
127.0.0.1:6379> SET customer:9000 jane
OK
127.0.0.1:6379> GET customer:9000
"jane"

what if i want to update customer name of customer:9000
SET Command

127.0.0.1:6379> SET customer:9000 "jane james"
OK
127.0.0.1:6379> GET customer:9000
"jane james"
127.0.0.1:6379>


127.0.0.1:6379> EXISTS customer:9000
(integer) 0
127.0.0.1:6379> SET customer:9000 jane
OK

You could first check with the exist command to see if the key is present before using SET.

But having two operations-- the exists followed by a set--means two round trips Redis and possible inconsistencies between the operations.


127.0.0.1:6379> EXISTS customer:9000
(integer) 0
127.0.0.1:6379> SET customer:9000 jane
OK

You could first check with the exist command to see if the key is present before using SET.

But having two operations-- the exists followed by a set--means two round trips Redis and possible inconsistencies between the operations.

NX -  for create
XX -  for update.

127.0.0.1:6379> SET customer:333 john NX
OK
127.0.0.1:6379> SET customer:333 john NX
(nil)
127.0.0.1:6379> SET customer:444 Karthik XX
(nil)
127.0.0.1:6379> SET customer:444 Karthik NX
OK
127.0.0.1:6379> SET customer:444 Karthik.K XX
OK
127.0.0.1:6379> GET customer:444
"Karthik.K"
127.0.0.1:6379>
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

Key removals:

1.you can remove key through commands - del,unlink. 
  This is not good idea , incase large amount of keys... -

2. auto delete ;
   it is good idea , when key is not usefull after some process/time.

Timers : Automatic Key Eviction:
.................................
timeout in sec- ex
timeout in msc -px
TTL key - to verify , how much time is there 
expire key sec - used to set timeout after key creation

Timers : Automatic Key Eviction:
.................................
timeout in sec- ex
timeout in msc -px
TTL key - to verify , how much time is there 
	
27.0.0.1:6379> SET seat-hold Row:A:Seat:4 EX 5000
OK
127.0.0.1:6379> get seat-hold
"Row:A:Seat:4"
127.0.0.1:6379> get seat-hold
"Row:A:Seat:4"
127.0.0.1:6379> get seat-hold
"Row:A:Seat:4"
127.0.0.1:6379> TTL seat-hold
(integer) 4957
127.0.0.1:6379> TTL seat-hold
(integer) 4952
127.0.0.1:6379> SET user:password something PX 10000
OK
127.0.0.1:6379> TTL user:password
(integer) -2
127.0.0.1:6379> get user:password
(nil)
127.0.0.1:6379> exists user:password
(integer) 0
127.0.0.1:6379> SET user:password something PX 10000
OK
127.0.0.1:6379> exists user:password
(integer) 1
127.0.0.1:6379> get user:password
"something"
127.0.0.1:6379> get user:password
(nil)
127.0.0.1:6379>


127.0.0.1:6379> expire customer:444 10
(integer) 1
127.0.0.1:6379> get customer:444
"Karthik.K"
127.0.0.1:6379> get customer:444
"Karthik.K"
127.0.0.1:6379> get customer:444
(nil)

//////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////

                                             Data types
1.String:
 -store alphabets
 -store numbers
 -store binary.
    -image,spreadsheets,html fragments

no int,float datatype.

There is a limit of 512 megabytes for any string value

JPEGs, Excel spreadsheets, HTML fragments, as well as
plain old regular text and numbers are permissible.

Internally, Redis stores encoding of the value, stores a knowledge of whether it is a text, number, or binary.
 1 - integer
 "a" - string
 binary - bytes-raw

How to know the type of key?

TYPE key


127.0.0.1:6379> SET  a 10
OK
127.0.0.1:6379> SET name "Subramanian"
OK
127.0.0.1:6379> SET b "10"
OK
127.0.0.1:6379> TYPE a
string
127.0.0.1:6379> TYPE name
string
127.0.0.1:6379> TYPE b
string
127.0.0.1:6379> SET c 10.5
OK
127.0.0.1:6379> TYPE c
string

Since string is Super Type, 10 also stored as string but it is numeric value.

Can i do some computation on numerical value.
Yes!

in order to know the internal type of string

OBJECT subcommand key

The OBJECT command allows to inspect the internals of Redis Objects associated with keys

OBJECT ENCODING <key> returns the kind of internal representation used in order to store the value associated with a key.


127.0.0.1:6379> SET  a 10
OK
127.0.0.1:6379> SET name "Subramanian"
OK
127.0.0.1:6379> SET b "10"
OK
127.0.0.1:6379> TYPE a
string
127.0.0.1:6379> TYPE name
string
127.0.0.1:6379> TYPE b
string
127.0.0.1:6379> SET c 10.5
OK
127.0.0.1:6379> TYPE c
string
127.0.0.1:6379> INCR a
(integer) 11
127.0.0.1:6379> INCR b
(integer) 11
127.0.0.1:6379> OBJECT ENCODING a
"int"
127.0.0.1:6379> OBJECT ENCODING b
"int"
127.0.0.1:6379> OBJECT ENCODING name
"embstr"
127.0.0.1:6379> OBJECT ENCODING c
"embstr"
127.0.0.1:6379> INCR name
(error) ERR value is not an integer or out of range
127.0.0.1:6379> INCR c
(error) ERR value is not an integer or out of range
127.0.0.1:6379> INCRBYFLOAT c
(error) ERR wrong number of arguments for 'incrbyfloat' command
127.0.0.1:6379> INCRBYFLOAT c 1
"11.5"
127.0.0.1:6379> INCRBYFLOAT c 1
"12.5"
127.0.0.1:6379> INCRBY a 10
(integer) 21
127.0.0.1:6379> INCRBY a 10
(integer) 31
127.0.0.1:6379> INCRBY a 10
(integer) 41
127.0.0.1:6379> INCRBY a -10
(integer) 31
127.0.0.1:6379> INCRBY a 10
(integer) 41
127.0.0.1:6379> INCRBY a -10
(integer) 31
127.0.0.1:6379> DECR a
(integer) 30
127.0.0.1:6379> DECRby a 5
(integer) 25
127.0.0.1:6379> DECRby a 5
(integer) 20
127.0.0.1:6379>
////////////////////////////////////////////////////////////////////////////////////////////
String operations:

-string length
-stringrange
-append

127.0.0.1:6379> STRLEN name
(integer) 11
127.0.0.1:6379> set name "Subramanian"
OK
127.0.0.1:6379> GETRANGE name 0 4
"Subra"
127.0.0.1:6379>

127.0.0.1:6379> APPEND name "Murugan"
(integer) 18
127.0.0.1:6379> get name
"SubramanianMurugan"
127.0.0.1:6379>
////////////////////////////////////////////////////////////////////////////////////////////
Bit Maps:
........

Collection of bits which forms a structure called bit map.

BitMaps are  a data type used within Redis and represents a long list of bits that contain 0 by default and we can use SETBIT Command to flip to 1 or 0


Key                    Value                               type
	
a_bitmap     0 0 0  0 0 0 0 0 0 0 0 0 0 0                  binary string


bitmap can store up to 2pow 32 bits,about 4 billion items

Use case: login use case

SETBIT logins:2017:04 6 1

here login:2017:04 is key
6 is offset , typically userid as offset
1 is active bit

SETBIT logins:2017:04 6 1

27.0.0.1:6379> SET login:today 7 1
(error) ERR syntax error
127.0.0.1:6379> SETBIT login:today 7 1
(integer) 0
127.0.0.1:6379> SETBIT login:today 7 0
(integer) 1
127.0.0.1:6379> GET login:today
"\x00"
127.0.0.1:6379> Type login:today
string
127.0.0.1:6379> object encoding login:today
"raw"
127.0.0.1:6379>

types:
 int -numbers
 embstr -embededstring
 raw - binary- bits
/////////////////////////////////////////////**************//////////////////////////////////
/////////////////////////////////////////////**************//////////////////////////////////

Hash:
.....

String stores single/scalar value only

 SET a 10

Hash Stores key-value pair values into one single key

    player:1
        name:xxx
        score:12
        status:available

H-SET =>HashSet

HSET key field value [field value ...]

127.0.0.1:6379> HSET player:1 name Subramanian score 80 status alive
(integer) 3
127.0.0.1:6379> HSET houseId:5150 numBedrooms 3 sqfeet 2700 hvac "forced air"
(integer) 3
1

internal represention would be like below
  
player:1 
       {
         name:'subramanina',
         score:80,
         status:'alive'
       }


houseID: 5150
	numBedrooms: 3
	squareFeet: 2700
	hvac: forced air


Commands:

HSET - to add field and values
HGETALL - to read all hash values
HGET  - TO get a particular key value
HSET - to update existing field or add new field value
HDEL - to delete a field value from existing hash
HINCRBY - to increment a field value

Reading Keys and key
......................
127.0.0.1:6379> HGETALL player:1
1) "name"
2) "Subramanian"
3) "score"
4) "80"
5) "status"
6) "alive"
127.0.0.1:6379> HGET player:1 name
"Subramanian"
127.0.0.1:6379> HGET player:1 status
"alive"
127.0.0.1:6379>


////////////////////////////////////////////////////////////////////////////////////////////
How to maniupulate a field in hashset?

HINCRBY key field increment
HINCRBYFLOAT key field increment

127.0.0.1:6379> HINCRBY player:1  score 5
(integer) 85
127.0.0.1:6379> HINCRBY player:1  score 5
........................................................

........................................................

How to update existing fields in hash set?

You can update single field or multiple fields?

127.0.0.1:6379> HSET player:1 name "Ram Kumar"
(integer) 0
127.0.0.1:6379> HGET player:1 name
"Ram Kumar"
127.0.0.1:6379> HSET player:1 name "Ram Kumar" score 10
(integer) 0
127.0.0.1:6379> HGETALL player:1
1) "name"
2) "Ram Kumar"
3) "score"
4) "10"
5) "status"
6) "alive"
127.0.0.1:6379>
.......................................................................................
.......................................................................................
How to add new field on existing hash?

127.0.0.1:6379> HSET player:1  level 5
(integer) 1
127.0.0.1:6379> HGETALL player:1
1) "name"
2) "Ram Kumar"
3) "score"
4) "10"
5) "status"
6) "alive"
7) "level"
8) "5"
127.0.0.1:6379>
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

How to delete field/s from hash?

HDEL key field [field ...]

27.0.0.1:6379> HGETALL player:1
1) "name"
2) "Ram Kumar"
3) "score"
4) "10"
5) "status"
6) "alive"
7) "level"
8) "5"
127.0.0.1:6379> HDEL player:1 status
(integer) 1
127.0.0.1:6379> HGETALL player:1
1) "name"
2) "Ram Kumar"
3) "score"
4) "10"
5) "level"
6) "5"
127.0.0.1:6379>

///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////

How to verify a particular field present or not on existing hash?

HEXISTS key field

127.0.0.1:6379> HEXISTS player:1 status
(integer) 0
127.0.0.1:6379> HEXISTS player:1 level
(integer) 1
127.0.0.1:6379>
...........................................................................................

...........................................................................................
How to extract only keys and values from Hash?

Keys Only:

127.0.0.1:6379> HKEYS player:1
1) "name"
2) "score"
3) "level"

Values Only:
127.0.0.1:6379> HVALS player:1
1) "Ram Kumar"
2) "10"
3) "5
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
                                     List
                                   .........

1.List is ordered collection of strings.
2.List maintains order based index, which starts 0th index.
3.Lists are dynamic array,you can add,delete items dynamically, as you add or delete,
  the size of list automatically expanded or shrinked.
4.Lists are implemented as "Doubly Linked List" : Linked List
5.You can add element at any position :  head / tail - left /right.
6.You can create other usefull data structures like "Queues/ Stacks,PQueues"
7.Duplicates are allowed.

//////////////////////////////////////////////////////////////////////////////////////////////
                                     List
                                   .........

1.List is ordered collection of strings.
2.List maintains order based index, which starts 0th index.
3.Lists are dynamic array,you can add,delete items dynamically, as you add or delete,
  the size of list automatically expanded or shrinked.
4.Lists are implemented as "Doubly Linked List" : Linked List
5.You can add element at any position :  head / tail - left /right.
6.You can create other usefull data structures like "Queues/ Stacks,PQueues"
7.Duplicates are allowed.

List Operations:

1.Add Elements at Head

LPUSH key element [element ...]

127.0.0.1:6379> LPUSH  names a b c d e
(integer) 5
127.0.0.1:6379>

............................................................

2.Get No of elemenents In the List

LLEN key

127.0.0.1:6379> LLEN names
(integer) 5
...................................................................
3.How read elements from left most?

127.0.0.1:6379> LPUSH  names a b c d e
(integer) 5

LPush adds element left side

Internal storage would be for LPUSH 
 e,d,c,a,b

127.0.0.1:6379> LRANGE names 0 5
1) "e"
2) "d"
3) "c"
4) "b"
5) "a"
127.0.0.1:6379> LRANGE names 2 5
1) "c"
2) "b"
3) "a"
127.0.0.1:6379> LRANGE names 3 5
1) "b"
2) "a"
...........................................................................................
3.1. How to read single element based on index?

LINDEX key index

 - 0 means first index element
 - -1 last tail element
 - outofindex - nil

127.0.0.1:6379> LRANGE names 0 7
1) "c"
2) "redis-cli"
3) "b"
4) "a"

Get the first element:

127.0.0.1:6379> LINDEX names 0
"c"

127.0.0.1:6379> LINDEX names 1
"redis-cli"
127.0.0.1:6379> LINDEX names -1
"a"
127.0.0.1:6379> LINDEX names -2
"b"
127.0.0.1:6379> LINDEX names 90
(nil)
127.0.0.1:6379>

/////////////////////////////////////////////////////////////////////////////////////////////

How to update/replace old node value into new node value?

Before update:
127.0.0.1:6379> LRANGE names 0 5
1) "e"
2) "d"
3) "c"
4) "b"
5) "a"

After update:
127.0.0.1:6379> LSET  names 0 "foo"
OK
127.0.0.1:6379> LRANGE names 0 5
1) "foo"
2) "d"
3) "c"
4) "b"
5) "a"
////////////////////////////////////////////////////////////////////////////////////////////

How to add element in the middle of the List?

LINSERT key BEFORE|AFTER pivot element


127.0.0.1:6379> LRANGE names 0 5
1) "foo"
2) "d"
3) "c"
4) "b"
5) "a"
127.0.0.1:6379> LINSERT names BEFORE "c" "redis"
(integer) 6
127.0.0.1:6379> LRANGE names 0 6
1) "foo"
2) "d"
3) "redis"
4) "c"
5) "b"
6) "a"
127.0.0.1:6379> LINSERT names AFTER "c" "redis-cli"
(integer) 7
127.0.0.1:6379> LRANGE names 0 7
1) "foo"
2) "d"
3) "redis"
4) "c"
5) "redis-cli"
6) "b"
7) "a"
///////////////////////////////////////////////////////////////////////////////////////////
How to remove element from the Left side?

LPOP key

Before Remove:
..............

127.0.0.1:6379> LRANGE names 0 7
1) "foo"
2) "d"
3) "redis"
4) "c"
5) "redis-cli"
6) "b"
7) "a"
127.0.0.1:6379> LPOP names
"foo"
127.0.0.1:6379> LPOP names
"d"
127.0.0.1:6379> LPOP names
"redis"

After Remove:
.............

127.0.0.1:6379> LRANGE names 0 7
1) "c"
2) "redis-cli"
3) "b"
4) "a"
127.0.0.1:6379>
////////////////////////////////////////////////////////////////////////////////////////////

RPUSH : Pushing elements towards right
......................................

RPUSH key element [element ...]

Add elements:

127.0.0.1:6379> RPUSH  counters 1 2 3 4 5 6 7 8 9 10
(integer) 10

127.0.0.1:6379> LRANGE counters 0 9
 1) "1"
 2) "2"
 3) "3"
 4) "4"
 5) "5"
 6) "6"
 7) "7"
 8) "8"
 9) "9"
10) "10"

127.0.0.1:6379> LRANGE counters 0 9
 1) "1"
 2) "2"
 3) "3"
 4) "4"
 5) "5"
 6) "6"
 7) "7"
 8) "8"
 9) "9"
10) "10"
127.0.0.1:6379> RPOP counters
"10"
127.0.0.1:6379> LPOP counters
"1"
127.0.0.1:6379>
/////////////////////////////////////////////////////////////////////////////////////////

Think how to implement stacks and queues using list?
.....................................................

STACK - LPUSH ,LPOP
Queue - RPUSH, LPOP
.........................................................................................

........................................................................................

                                      SET
............................................................................................ 

Sets:
 -Unordered collection without duplicate values.
 -Provides mathmetical set operations - union,intersection,difference.

How to create set / how to add elements set?

SADD key member [member ...]

127.0.0.1:6379> SADD hitcounters 1 1 2 3 3 4 5 6 7 8 8
(integer) 8

How to get all keys and values?

SSCAN key cursor [MATCH pattern] [COUNT count]

127.0.0.1:6379> SSCAN hitcounters 0 MATCH *
1) "0"
2) 1) "1"
   2) "2"
   3) "3"
   4) "4"
   5) "5"
   6) "6"
   7) "7"
   8) "8"
127.0.0.1:6379>

////////////////////////////////////////////////////////////////////////////////////////

Cardinality: SCARD

SCARD key

-Returns the set cardinality (number of elements) of the set stored at key.

127.0.0.1:6379> SCARD hitcounters
(integer) 8

////////////////////////////////////////////////////////////////////////////////////////////

Differences:SDIFF

SDIFF key [key ...]

-Returns the members of the set resulting from the difference between the first set and all the successive sets.

127.0.0.1:6379> SADD key1 a b c d
(integer) 4
127.0.0.1:6379> SADD key2 c
(integer) 1
127.0.0.1:6379> SADD key3 a c e
(integer) 3
127.0.0.1:6379> SDIFF key1 key2 key3
1) "b"
2) "d"
////////////////////////////////////////////////////////////////////////////////////////////

Union : eleminate common elements

127.0.0.1:6379> sadd key1  a b c d e
(integer) 5
127.0.0.1:6379> sadd key2 c
(integer) 1
127.0.0.1:6379> sadd key3 f g c
(integer) 3
127.0.0.1:6379> sunion key1 key2 key3
1) "f"
2) "c"
3) "b"
4) "a"
5) "d"
6) "e"
7) "g"
127.0.0.1:6379>
///////////////////////////////////////////////////////////////////////////////////////////////
Intersection: Common element

SINTER key [key ...]

Returns the members of the set resulting from the intersection of all the given sets.

127.0.0.1:6379> SADD key1 a b c d
(integer) 4
127.0.0.1:6379> SADD key2 c
(integer) 1
127.0.0.1:6379> SADD key3 a c e

127.0.0.1:6379> SINTER key1 key2 key3
1) "c"

//////////////////////////////////////////////////////////////////////////////////////////

How to get members of a given set?

SMEMBERS key


127.0.0.1:6379> SMEMBERS key1
1) "c"
2) "d"
3) "b"
4) "a"
127.0.0.1:6379> SMEMBERS key2
1) "c"
127.0.0.1:6379> SMEMBERS key3
1) "c"
2) "e"
3) "a"
127.0.0.1:6379>
///////////////////////////////////////////////////////////////////////////////////////////

To test whether an element is member of a given set?

SISMEMBER key member
 
1-means memeber
0-means not a member

127.0.0.1:6379> SISMEMBER key1 a
(integer) 1
127.0.0.1:6379> SISMEMBER key1 ab
(integer) 0
127.0.0.1:6379>

////////////////////////////////////////////////////////////////////////////////////////////

How to remove element from Set?

Remove from first index

SPOP key [count]

127.0.0.1:6379> SMEMBERS key1
1) "c"
2) "d"
3) "b"
4) "a"
127.0.0.1:6379> SPOP key1
"a"
127.0.0.1:6379> SMEMBERS key1
1) "c"
2) "d"
3) "b"
127.0.0.1:6379> SPOP key1  2
1) "c"
2) "d"
127.0.0.1:6379> SMEMBERS key1
1) "b"
127.0.0.1:6379>

Remove based on element

SREM key member [member ...]

127.0.0.1:6379> SMEMBERS key1
1) "c"
2) "d"
3) "b"
4) "a"
5) "e"
127.0.0.1:6379> SREM key1 c
(integer) 1
127.0.0.1:6379> SMEMBERS key1
1) "d"
2) "b"
3) "a"
4) "e"
////////////////////////////////////////////////////////////////////////////////////////
How to select random values from the set?

SRANDMEMBER key [count]

127.0.0.1:6379> SRANDMEMBER key1
"d"
127.0.0.1:6379> SRANDMEMBER key1
"d"
127.0.0.1:6379> SRANDMEMBER key1
"b"
127.0.0.1:6379> SRANDMEMBER key1 2
1) "e"
2) "a"
127.0.0.1:6379> SRANDMEMBER key1 2
1) "d"
2) "b"
127.0.0.1:6379> SRANDMEMBER key1 2
1) "d"
2) "b"

//////////////////////////////////////////////////////////////////////////////////////////////
                                   
                                      SORTED SET
///////////////////////////////////////////////////////////////////////////////////////////////

 -Sorted set is similar to set with sorting feature. asc or dec order - based on numbers/charcaters

127.0.0.1:6379> ZADD myset 1 a
(integer) 1
127.0.0.1:6379> ZADD myset 1 a
(integer) 0
127.0.0.1:63
79> ZADD myset 1 b
(integer) 1
127.0.0.1:6379> ZADD myset 2 c 3 d
(integer) 2
127.0.0.1:6379> ZRANGE myset 0 -1 WITHSCORES
1) "a"
2) "1"
3) "b"
4) "1"
5) "c"
6) "2"
7) "d"
8) "3"
127.0.0.1:6379> ZRANGE myset 0 -1
1) "a"
2) "b"
3) "c"
4) "d"
127.0.0.1:6379> ZADD myset 0 e
(integer) 1
127.0.0.1:6379> ZRANGE myset 0 -1
1) "e"
2) "a"
3) "b"
4) "c"
5) "d"
127.0.0.1:6379> ZADD myset 10 foo
(integer) 1
127.0.0.1:6379> ZADD myset 5 bar
(integer) 1
127.0.0.1:6379> ZRANGE myset 0 -1
1) "e"
2) "a"
3) "b"
4) "c"
5) "d"
6) "bar"
7) "foo"
127.0.0.1:6379> ZADD myset 9 foobar
(integer) 1
127.0.0.1:6379> ZRANGE myset 0 -1
1) "e"
2) "a"
3) "b"
4) "c"
5) "d"
6) "bar"
7) "foobar"
8) "foo"
127.0.0.1:6379>

Note: 
 sorting happens based "score" values, incase scores are same, then redis sorts according to
 ordered lexicographically of values.

Note: Most of the Sort apis available inside Sorted Set + Some advanced apis also , which is based on scores and ranks.
/////////////////////////////////////////////////////////////////////////////////////////////
hyperloglogs, geospatial indexes, and streams -Advanced types
.............................................................................................

                                      Administration
.............................................................................................

RDBMS stores data inside schema.
Does redis stores data inside schema?
 yes!.....

Storage:

 Redis is 200% in memory data store -  all data is stored inside RAM.
 Redis stores data in logical isloation that is called db.
 Redis has default 16 databases(storage),named as 0,1- default is 0.

Lab 6 :Data base information:
selectdb 0 
 switching database to databse
swapdb 0 1
  move keys from 0 to 1 
flushdb 
  removes all keys in a selected db
flushall 
  removes all keys in all database
removes particular key
del 
unlink
//////////////////////////////////////////////////////////////////////////////////////////

Lab 7: How to start redis server with configuration?

Starting redis server with configuration?

./redis-server /path/to/redis.conf


src/redis-server redis.conf
14271:C 17 Mar 2021 09:35:36.898 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
14271:C 17 Mar 2021 09:35:36.898 # Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=14271, just started
14271:C 17 Mar 2021 09:35:36.898 # Configuration loaded
14271:M 17 Mar 2021 09:35:36.899 * Increased maximum number of open files to 10032 (it was originally set to 1024).
14271:M 17 Mar 2021 09:35:36.899 * monotonic clock: POSIX clock_gettime
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 6.2.1 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6381
 |    `-._   `._    /     _.-'    |     PID: 14271
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

14271:M 17 Mar 2021 09:35:36.900 # Server initialized
14271:M 17 Mar 2021 09:35:36.900 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
14271:M 17 Mar 2021 09:35:36.901 * Loading RDB produced by version 6.2.1
14271:M 17 Mar 2021 09:35:36.901 * RDB age 310 seconds
14271:M 17 Mar 2021 09:35:36.901 * RDB memory usage when created 0.83 Mb
14271:M 17 Mar 2021 09:35:36.901 * DB loaded from disk: 0.000 seconds
14271:M 17 Mar 2021 09:35:36.901 * Ready to accept connections

/////////////////////////////////////////////////////////////////////////////////////////////

Lab 8 : How to inspect the redis server information?


Category of server information:
...............................

server: General information about the Redis server
clients: Client connections section
memory: Memory consumption related information
persistence: RDB and AOF related information
stats: General statistics
replication: Master/replica replication information
cpu: CPU consumption statistics
commandstats: Redis command statistics
cluster: Redis Cluster section
modules: Modules section
keyspace: Database related statistics
modules: Module related sections
errorstats: Redis error statistics


127.0.0.1:6379> info

# Server
redis_version:6.0.4
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:d5d470262d47f1a0
redis_mode:standalone
os:Linux 5.4.39-linuxkit x86_64
arch_bits:64
multiplexing_api:epoll
atomicvar_api:atomic-builtin
gcc_version:8.3.0
process_id:1
run_id:40543dac7951c11291c95a053a7246e647b36305
tcp_port:6379
uptime_in_seconds:47891
uptime_in_days:0
hz:10
configured_hz:10
lru_clock:13047257
executable:/data/redis-server
config_file:

# Clients
connected_clients:2
client_recent_max_input_buffer:2
client_recent_max_output_buffer:0
blocked_clients:0
tracking_clients:0
clients_in_timeout_table:0

# Memory
used_memory:893520
used_memory_human:872.58K
used_memory_rss:7598080
used_memory_rss_human:7.25M
used_memory_peak:893520
used_memory_peak_human:872.58K
used_memory_peak_perc:100.17%
used_memory_overhead:837156
used_memory_startup:802848
used_memory_dataset:56364
used_memory_dataset_perc:62.16%
allocator_allocated:936504
allocator_active:1224704
allocator_resident:3592192
total_system_memory:2084323328
total_system_memory_human:1.94G
used_memory_lua:37888
used_memory_lua_human:37.00K
used_memory_scripts:0
used_memory_scripts_human:0B
number_of_cached_scripts:0
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
allocator_frag_ratio:1.31
allocator_frag_bytes:288200
allocator_rss_ratio:2.93
allocator_rss_bytes:2367488
rss_overhead_ratio:2.12
rss_overhead_bytes:4005888
mem_fragmentation_ratio:8.93
mem_fragmentation_bytes:6747072
mem_not_counted_for_evict:0
mem_replication_backlog:0
mem_clients_slaves:0
mem_clients_normal:33972
mem_aof_buffer:0
mem_allocator:jemalloc-5.1.0
active_defrag_running:0
lazyfree_pending_objects:0

# Persistence
loading:0
rdb_changes_since_last_save:3
rdb_bgsave_in_progress:0
rdb_last_save_time:1606879301
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:1
rdb_current_bgsave_time_sec:-1
rdb_last_cow_size:200704
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok
aof_last_cow_size:0
module_fork_in_progress:0
module_fork_last_cow_size:0

# Stats
total_connections_received:9
total_commands_processed:107
instantaneous_ops_per_sec:0
total_net_input_bytes:3636
total_net_output_bytes:227343
instantaneous_input_kbps:0.00
instantaneous_output_kbps:0.00
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
expired_stale_perc:0.00
expired_time_cap_reached_count:0
expire_cycle_cpu_milliseconds:292
evicted_keys:0
keyspace_hits:4
keyspace_misses:2
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:164
migrate_cached_sockets:0
slave_expires_tracked_keys:0
active_defrag_hits:0
active_defrag_misses:0
active_defrag_key_hits:0
active_defrag_key_misses:0
tracking_total_keys:0
tracking_total_items:0
tracking_total_prefixes:0
unexpected_error_replies:0

# Replication
role:master
connected_slaves:0
master_replid:f5f98535613d1293befd8f298280c5f9819a8c97
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:15.790574
used_cpu_user:12.802565
used_cpu_sys_children:0.005145
used_cpu_user_children:0.002969

# Modules

# Cluster
cluster_enabled:0

# Keyspace
db0:keys=4,expires=0,avg_ttl=0
db1:keys=1,expires=0,avg_ttl=0
db2:keys=1,expires=0,avg_ttl=0
127.0.0.1:6379>
//////////////////////////////////////////////////////////////////////////////////////

Lab 9: How to restirct maxnoof clients by redis server?

open redis.conf file and edit

################################### CLIENTS ####################################

# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients, however if the Redis server is not
# able to configure the process file limit to allow for the specified limit
# the max number of allowed clients is set to the current file limit
# minus 32 (as Redis reserves a few file descriptors for internal uses).
#
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
#
# IMPORTANT: When Redis Cluster is used, the max number of connections is also
# shared with the cluster bus: every node in the cluster will use two
# connections, one incoming and another outgoing. It is important to size the
# limit accordingly in case of very large clusters.
#
maxclients 3

Client connections:

$cd src/redis-cli -p 6381
  > set a 10
  ok

$cd src/redis-cli -p 6381
  > set a 10
  ok
$cd src/redis-cli -p 6381
  > set a 10
  ERR MAX NO OF clients reached.

.............................................................................................

Lab 10: What if i want to change configuration while server is running? 

Types of configuration:

1.static configuration
    configuation is applied during server startup.
2.dynamic configuration
    configuration can set after server startup, while running.

static configuration can be loaded
  -from default server config
  -from redis.conf file

how to set /and get configuration dynamically?


How to use change server configuration during server up?

via command 

config set directive value
config get directive
config get * 

config set maxclients 5

config set timeout 1000
///////////////////////////////////////////////////////////////////////////////////////////

How to get Client specific information?

127.0.0.1:6379> client list
id=11 addr=127.0.0.1:42592 fd=8 name= age=6684 idle=4496 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get user=default
id=12 addr=127.0.0.1:42594 fd=9 name=myclient age=4275 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client user=default
127.0.0.1:6379>

How to change client name?

127.0.0.1:6379> client setname myclient
OK
127.0.0.1:6379> client getname
"myclient"
127.0.0.1:6379>
/////////////////////////////////////////////////////////////////////////////////////////////

Monitoring Redis Server:

                     Slow Log : Monitoring Slow Redis Calls.
 
       Monitor commands which are blocking longer time than we specified timeout.


1.The Redis Slow Log is a "system" to log queries that exceeded a specified
execution time.
2.The execution time does not include the I/O operations
like talking with the client, sending the reply and so forth,
but just the time needed to actually execute the command (this is the only
stage of command execution where the thread is blocked and can not serve
other requests in the meantime).

How long a thread can be blocked?

You can configure the slow log with two parameters:
  one tells Redis what is the execution time, in microseconds, to exceed in order for the
command to get logged, and the other parameter is the length of the
slow log. 

When a new command is logged the oldest one is removed from the queue of logged commands.
  

The following time is expressed in microseconds, so 1000000 is equivalent
to one second. Note that a negative number disables the slow log, while
a value of zero forces the logging of every command.

slowlog-log-slower-than 10000

There is no limit to this length. Just be aware that it will consume memory.
You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128

Lab 11: 

CONFIG SET slowlog-log-slower-than 5000
CONFIG SET slowlog-max-len 50

debug sleep .5

debug commad is used to enable debugging.

sleep command is used to block current for given amount of time.

127.0.0.1:6379> SLOWLOG GET
1) 1) (integer) 1
   2) (integer) 1615980138
   3) (integer) 100146
   4) 1) "debug"
      2) "sleep"
      3) ".10"
   5) "127.0.0.1:43156"
   6) ""
2) 1) (integer) 0
   2) (integer) 1615979917
   3) (integer) 500111
   4) 1) "debug"
      2) "sleep"
      3) ".5"
   5) "127.0.0.1:43156"
   6) ""
/////////////////////////////////////////////////////////////////////////////////////////////

How to monitor memory?

 1) MEMORY <subcommand> [<arg> [value] [opt] ...]. Subcommands are:
 2) DOCTOR
 3)     Return memory problems reports.
 4) MALLOC-STATS    Return internal statistics report from the memory allocator.
 5) PURGE
 6)     Attempt to purge dirty pages for reclamation by the allocator.
 7) STATS
 8)     Return information about the memory usage of the server.
 9) USAGE <key> [SAMPLES <count>]
10)     Return memory in bytes used by <key> and its value. Nested values are
11)     sampled up to <count> times (default: 5).
12) HELP
13)     Prints this help.

127.0.0.1:6379> memory stats
 1) "peak.allocated"
 2) (integer) 933544
 3) "total.allocated"
 4) (integer) 872408
 5) "startup.allocated"
 6) (integer) 809856
 7) "replication.backlog"
 8) (integer) 0
 9) "clients.slaves"
10) (integer) 0
11) "clients.normal"
12) (integer) 20504
13) "aof.buffer"
14) (integer) 0
15) "lua.caches"
16) (integer) 0
17) "db.0"
18) 1) "overhead.hashtable.main"
    2) (integer) 72
    3) "overhead.hashtable.expires"
    4) (integer) 0
19) "overhead.total"
20) (integer) 830432
21) "keys.count"
22) (integer) 1
23) "keys.bytes-per-key"
24) (integer) 62552
25) "dataset.bytes"
26) (integer) 41976
27) "dataset.percentage"
28) "67.105766296386719"
29) "peak.percentage"
30) "93.451194763183594"
31) "allocator.allocated"
32) (integer) 1244440
33) "allocator.active"
34) (integer) 1536000
35) "allocator.resident"
36) (integer) 3772416
37) "allocator-fragmentation.ratio"
38) "1.2342901229858398"
39) "allocator-fragmentation.bytes"
40) (integer) 291560
41) "allocator-rss.ratio"
42) "2.4560000896453857"
43) "allocator-rss.bytes"
44) (integer) 2236416
45) "rss-overhead.ratio"
46) "1.5092290639877319"
47) "rss-overhead.bytes"
48) (integer) 1921024
49) "fragmentation"
50) "6.848081111907959"
51) "fragmentation.bytes"
52) (integer) 4862048
//////////////////////////////////////////////////////////////////////////////////////////////

Latency Check:


127.0.0.1:6379> CONFIG SET latency-monitor-threshold 100
OK
127.0.0.1:6379> debug sleep 1
OK
(1.00s)
127.0.0.1:6379> latency latest
1) 1) "command"
   2) (integer) 1606872783
   3) (integer) 1000
   4) (integer) 1000
127.0.0.1:6379> debug sleep .25
OK
127.0.0.1:6379> latency latest
1) 1) "command"
   2) (integer) 1606872827
   3) (integer) 250
   4) (integer) 1000
127.0.0.1:6379> latency history command
1) 1) (integer) 1606872783
   2) (integer) 1000
2) 1) (integer) 1606872827
   2) (integer) 250
127.0.0.1:6379> latency doctor
Dave, I have observed latency spikes in this Redis instance. You don't mind talking about it, do you Dave?

1. command: 2 latency spikes (average 625ms, mean deviation 375ms, period 56.00 sec). Worst all time event 1000ms.

I have a few advices for you:

- Check your Slow Log to understand what are the commands you are running which are too slow to execute. Please check http://redis.io/commands/slowlog for more information.
- Deleting, expiring or evicting (because of maxmemory policy) large objects is a blocking operation. If you have very large objects that are often deleted, expired, or evicted, try to fragment those objects into multiple smaller objects.
127.0.0.1:6379>  latency reset command
(integer) 1
127.0.0.1:6379>  debug sleep .1
OK
127.0.0.1:6379>  debug sleep .2
OK
127.0.0.1:6379>  debug sleep .3
OK
127.0.0.1:6379>  debug sleep .5
OK
(0.50s)
127.0.0.1:6379>  debug sleep .4
OK
127.0.0.1:6379> latency graph command
command - high 500 ms, low 100 ms (all time high 500 ms)
--------------------------------------------------------------------------------
   #_
  _||
 _|||
_||||

22219
9523s
ssss
127.0.0.1:6379>
//////////////////////////////////////////////////////////////////////////////////////////////

Todo List:

1.Persistancy - snapshoting.
2.Replication - Master/replicat
3.High availability - Cluster
4.How to secure redis.






